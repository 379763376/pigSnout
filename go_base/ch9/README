基于共享变量的并发


1.竞争条件
竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果

函数并发安全的情况：
一个函数在线性程序中可以正确地工作
在并发的情况下，这个函数依然可以正确地工作
并发安全的函数不需要额外的同步工作
==》类型是并发安全的话 ，类型的一些方法和操作函数就都是并发安全的

并发安全的类型是例外
导出包级别的函数一般情况下都是并发安全的 ，package级的变量没法被限制在单 一的gorouine，修改这些变量“必须”使用互斥条件

两个goroutine并发访问一个变量 只要有一个有写操作就会发生数据竞争

三种方式可以避免数据竞争：
一、不要去写变量：在创建goroutine之前的初始化阶段，就初始化了map中的所有条目并且再也 不去修改它们
二、避免从多个goroutine访问变量：func goroutine是唯一一个能够访问变量的goroutine,变量都被限定在了一个单独的goroutine中;不要使用共享数据来通信；使用通信来 共享数据
    bank1案例：变量被限制在了monitor goroutine中
    对变量的所有访问就是线性的：流水线的每一个阶段都能够避免在将变量传送到下 一阶段时再去访问它
三、同一个时刻最多只有一 个goroutine在访问
    “互斥” 允许很多goroutine去访问变量


2.sync.Mutex互斥锁
    bank2案例：二元信号量
    系统内置互斥锁sync.Mutex
    用函数封装变量,函数加了互斥锁 ==> 监控monitor

函数中使用defer确保最后不管程序是否正常执行,都解锁了

Go的互斥量不能重入 : 解决方案是将一个函数分离为多个函数 :
    一个不导出的函数
    导出的函数,调用不导出的函数,在调用前会先去获取锁

3.sync.RWMutex读写锁
    只读操作并行执行，但写操作会完全互斥,“多读单写”锁
    RLock只能在临界区共享变量没有任何写入操作时可用
    RWMutex比一般的无竞争锁的mutex慢一些, 因为复杂的内部记录

4.内存同步
现在的CPU和编译器可能会断定两条语句的顺序不会影响执行结果，并且会交换两个语句的执行顺序

所有并发的问题都可以用一致的、简单的既定的模式来规避
将变量限定在goroutine内部
如果是多个goroutine都需要访问的变量，使用互斥条件来访问

5.sync.Once初始化
解决同时调用时发现值为空都去初始化,或者初始化了还没赋值 直接拿了个空的回来

一次性的初始化需要一个互斥量mutex和一个boolean变量来记录初始化是不是已经完成了


6.竞争条件检测
go build/run/test  加-race ,会使编译器创建附带了能够记录所有运行期对共享变量访问工具的test
会记录下每一个读或者写共享变量的goroutine的身份信息
会记录下所有的同步事件，比如go语句，channel操作，以及对(*sync.Mutex).Lock，(*sync.WaitGroup).Wait等等的调用

只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争
所以为了使结果尽量正确,请保证你的测试并发地覆盖到了你到包

7.并发的非阻塞缓存
并发程序出现没有现成的库可以解决的问题
缓存(memoizing)函数
在对函数进行调用的时候，我们就只需要一次计算，之后只要返回计算的结果就可以了

go test -run=TestConcurrent -race -v gopl.io/ch9/memo1
竞争检测器
Get不是并发安全的，存在数据竞争
给Memo加上一个mutex

8.goroutines和线程


