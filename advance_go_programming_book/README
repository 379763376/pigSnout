1.数组
var d = [...]int{1, 2, 4: 5, 6}
2.字符串
[]byte("世界abc")
[]rune("世界")
string([]rune{'世', '界'})
utf8.DecodeRuneInString(s)
string(bytes)
3.切片
4.函数
5.方法
将方法还原为普通类型的函数
6.接口
无意之间的适配
给接口定义一个私有方法，私有方法的名字是包含包的绝对路径名的，只能在包内部实现这个私有方法才能满足这个接口
以上两种方法都不能保证安全
7.原子操作
sync.Mutex 互斥锁

sync/atomic 多线程中访问也是安全的

单件模式（单例模式）
在性能敏感的地方可以增加一个数字型的标志位，通过原子检测标志位状态降低互斥锁的使用次数来提高性能
基于sync.Once实现单件模式

sync/atomic 包对基本的数值类型及复杂对象的读写都提供了原子操作的支持

实现一致性内存模型
希望多个goroutine之间满足顺序一致性内存模型

所有的 init 函数和 main 函数都是在主线程完成
某个 init 函数内部用go关键字启动了新的Goroutine的话， 新的Goroutine和 main.main 函数是并发执行的
8.goroutine
9.channel

10.并发模式
其他语言：简单的并发问题通过原子操作或互斥锁就能很好地实现
GO：共享的值通过Channel传递，在任意给定的时刻， 最好只有一个Goroutine能够拥有该资源
基于channel确保后台goroutine执行完成
基于sync.WaitGroup等待后台goroutine执行完成

11.生产者消费者模型
channel   in和out
signal.Notify 从用户输入 Ctrl-C 时才真正退出程序

12.发布订阅模型
订阅者管道是一个管道
主题类型筛选器
发布者结构体包含：
    读写锁、缓存、超时、订阅者和主题map
发布者构造器
发布者类型方法：
    新增订阅者：就是新增一个管道
    新增订阅者和主题：创建管道 修改了发布者的订阅者和主题map
    退出订阅：从订阅者和主题map中删除订阅者管道
    发布主题：循环发布者的订阅者和主题map 执行发送任务
    关闭发布者：循环删除订阅者，关闭管道
    发送主题：发送主题 容忍一定时间超时

订阅者和发布者可以在运行时动态添加

13.多开几个goroutine 返回数据到一个channel，接受者只接收第一个返回的
14.素数筛
channel刚开始接收2以上自然数，第一个素数2
第一次过筛启动了一个后台goroutine，接收的数是初始自然数channel,只接受%2！=0 ,把这个新的队列作为数据源。得到下一个素数3
第二次过筛接收上一个筛子过来的数据，这次加过滤条件%3！=0，得到第三个数组5
。。。。。。
循环99次，数据已经过滤了可以被小于下一个素数可除的数，得到下一个素数

以上每个并发体处理的任务太细微，每个小任务都起一个并发
细粒度的并发， CSP模型中固有的消息传递的代价太高了