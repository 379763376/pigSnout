1.数组
var d = [...]int{1, 2, 4: 5, 6}
2.字符串
[]byte("世界abc")
[]rune("世界")
string([]rune{'世', '界'})
utf8.DecodeRuneInString(s)
string(bytes)
3.切片
4.函数
5.方法
将方法还原为普通类型的函数
6.接口
无意之间的适配
给接口定义一个私有方法，私有方法的名字是包含包的绝对路径名的，只能在包内部实现这个私有方法才能满足这个接口
以上两种方法都不能保证安全
7.原子操作
sync.Mutex 互斥锁

sync/atomic 多线程中访问也是安全的

单件模式（单例模式）
在性能敏感的地方可以增加一个数字型的标志位，通过原子检测标志位状态降低互斥锁的使用次数来提高性能
基于sync.Once实现单件模式

sync/atomic 包对基本的数值类型及复杂对象的读写都提供了原子操作的支持

实现一致性内存模型
希望多个goroutine之间满足顺序一致性内存模型

所有的 init 函数和 main 函数都是在主线程完成
某个 init 函数内部用go关键字启动了新的Goroutine的话， 新的Goroutine和 main.main 函数是并发执行的
8.goroutine
9.channel

10.并发模式
其他语言：简单的并发问题通过原子操作或互斥锁就能很好地实现
GO：共享的值通过Channel传递，在任意给定的时刻， 最好只有一个Goroutine能够拥有该资源
基于channel确保后台goroutine执行完成
基于sync.WaitGroup等待后台goroutine执行完成

11.生产者消费者模型
channel   in和out
signal.Notify 从用户输入 Ctrl-C 时才真正退出程序

12.发布订阅模型
订阅者管道是一个管道
主题类型筛选器
发布者结构体包含：
    读写锁、缓存、超时、订阅者和主题map
发布者构造器
发布者类型方法：
    新增订阅者：就是新增一个管道
    新增订阅者和主题：创建管道 修改了发布者的订阅者和主题map
    退出订阅：从订阅者和主题map中删除订阅者管道
    发布主题：循环发布者的订阅者和主题map 执行发送任务
    关闭发布者：循环删除订阅者，关闭管道
    发送主题：发送主题 容忍一定时间超时

订阅者和发布者可以在运行时动态添加

13.多开几个goroutine 返回数据到一个channel，接受者只接收第一个返回的
14.素数筛
channel刚开始接收2以上自然数，第一个素数2
第一次过筛启动了一个后台goroutine，接收的数是初始自然数channel,只接受%2！=0 ,把这个新的队列作为数据源。得到下一个素数3
第二次过筛接收上一个筛子过来的数据，这次加过滤条件%3！=0，得到第三个数组5
。。。。。。
循环99次，数据已经过滤了可以被小于下一个素数可除的数，得到下一个素数

以上每个并发体处理的任务太细微，每个小任务都起一个并发
细粒度的并发， CSP模型中固有的消息传递的代价太高了
15.并发的安全退出
select
    随机选一个可用的分支
    没有可用选default
    否则阻塞  select{}也会阻塞
<-time.After(time.Second) 初始退出
后台逻辑写在select中，当收到close信号是case被匹配到 可以退出当前的goroutine
使用sync.WaitGroup保证每个后台goroutine任务都清理完成，再退出主goroutine
16.context包
线程安全退出或超时的控制
使用时结合sync
当main函数完成工作前，调用cancel()通知后台goroutine退出，避免goroutine泄漏
17.错误和异常
syscall.Errno
defer
recover
即使在包内部使用了 panic ， 但是在导出函数时会被转化为明确的错误值

错误的上下文
上层用户获取新的错误，丢失底层最基础的错误类型
包装原始错误，保留完整的原始错误类型，方便定位
支持RPC等跨网络传输，错误序列化为json数据

recover 函数调用有着更严格的要求:我们必须在 defer 函数中直接调用recover
嵌套的 defer 函数中调用 recover 也将导致无法捕获异常
必须要和有异常的栈帧只隔一个栈帧，recover 函数才能正常捕获异常
recover 函数捕获的是祖父一级调用函数栈帧的异常

switch类型断言，对不同的错误捕获执行不同的处理

