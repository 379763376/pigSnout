1.接口约定
接口只定义方法，使用者只用知道这个接口可以干什么
fmt.Printf和Sprintf
    这两个函数内部都是用了fmt.Fprintf函数进行封装
    函数的第一个参数类型需要接受一个实现了io.Writer接口的类型实例
fmt.Stringer
    给一个类型定义一个String方法，在打印类型对象的时候就可以使用这个方法

2.接口类型
io.Writer只要实现了[]bytes写入就是接口实现，例如文件、内存缓冲区、网络连接、http客户端、压缩工具、哈希
io.Reader类型的实现 只要实现了读取[]byte
io.Closer关闭任何可以关闭的

go接口定义习惯--单接口方法

接口内嵌

3.实现接口条件
T类型可以调用*T的方法，是隐式的获取到了地址
T类型不具有*T类型的方法
比如*T有String()方法，那么*T实现了fmt.Stringer接口

interface{} 空接口 对实现它的类型没有要求  将任意一个值赋给空接口类型
编译期间断言 *bytes.Buffer的值实现了io.Writer接口类型

nil 强制类型转换为实现类型，
var _ io.Writer = (*bytes.Buffer)(nil)

4.flat.Value接口
flag.Duration返回一个time.Duration类型实例，该类型实现了String方法
如果实例对象有String()方法，fmt.Printf打印实例的时候会调用实例的String()方法

实现通过命令行调用函数时，根据变量名传入参数变量值
实现flag.Value接口方法并封装为一个对外提供服务的函数
接口实现和调用函数封装步骤：
    a.定义一个Flag结构体 包含一个结构体
    b.Flag结构体指针 实现Set方法
    fmt.Sscanf：使用接收一个string 安装format分割，传递给指定的变量
    修改实例中的成员值
    c.封装一个函数，返回Flag结构体成员
    flag.CommandLine.Var
        第一个参数是Value接口类型，这个传入实现类型celsiusFlag的实例
        第二个参数是name是标记
        第三个是使用说明
函数调用：
    调用封装函数，拿到这个实例，如果输入错误在调用Flag结构体Set方法的时候会报错
    打印实例会调用实例的String()方法

5.接口值
接口值由两部分组成：具体的类型、类型的值
接口的零值就是它的类型和值的部分都是nil
可以把接口对象和nil比较，判断接口是否为空
调用一个空接口值上的任意方法都会产生panic

赋值过程 调用了一个具体类型到接口类型的隐式转换，

接口具体类型是可比较类型时，可以把接口作为map的key ,可以用作switch的操作数
如果动态类型是不可比较，则会panic

获取接口值得动态类型fmt.Printf("%T\n", w)

对于动态类型非nil,接口值是nil,在调用方法动态类型的方法时，如果nil是一个无效的接受者 就会报panic
(*bytes.Buffer).Write 接受者要求是非空，nil的*bytes.Buffer指针有实现这个接口的方法 调用类型方法会panic

接口方法参数类型是可以接受nil类型，定义变量的时候使用接口类型定义，而非实现类型




5.1.一个包含nil指针的接口不是nil接口
6.sort.Interface接口
7.http.Handler接口
8.error接口
9.