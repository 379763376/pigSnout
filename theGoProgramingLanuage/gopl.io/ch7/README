接口类型
抽象概括：对其他类型行为抽象概括
go中的接口是隐式实现的，实现了接口中的方法
场景：
    引用一些不受我们控制的包时，对于已经存在的具体类型定义一个新的接口

1.接口约定
接口类型对象不会暴露：对象的内部值的结构 和 对象支持的基础操作的集合
接口类型对象会暴露：自己的方法
fmt.Printf和Sprintf
    省去了对格式化部分的重复实现，都是fmt.Fprintf来进行封装
    函数func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)
    第一个参数io.Writer是接口类型，传参对象必须有一个Write函数，证明这个对象就是接口的实现类型
        io.Writer类型定义了函数Fprintf和这个函数调用者之间的约定 是一个可以调用Write函数的值
    bytecounter案例：一个实现了接口方法Write的类型
    fmt.Stringer接口定义了String方法，类型实现了String方法,

2.接口类型
    定义了一些列方法的集合，实现了所有实现方法的抽象
        Write(p []byte) (n int, err error)
        Read(p []byte) (n int, err error)
        Close() error
    接口类型的实例：实现了这些方法的具体类型
    组合已有接口--接口内嵌
        type ReadWriter interface {
            Reader
            Writer
        }
        type ReadWriter interface {
            Read(p []byte) (n int, err error)
            Write(p []byte) (n int, err error)
        }
        type ReadWriter interface {
            Read(p []byte) (n int, err error)
            Writer
        }
3.实现接口条件
    定义接口对象
    接口对象赋值
        具体类型对象赋值给接口对象
        接口对象赋值给接口对象（接口A赋值一个大范围的接口B（B包含A））
    os.Stdout实现了Reader Writer Closer
    类型方法的接收器是指针类型时，需要用一个可寻址对象去调用方法

    interface{} 空接口 对实现它的类型没有要求  将任意一个值赋给空接口类型
    var w io.Writer = new(bytes.Buffer) 编译期间断言 *bytes.Buffer的值实现了io.Writer接口类型
    var _ io.Writer = (*bytes.Buffer)(nil) 显示的转换都实现了这个接口
    
    指针类型或引用类型都有可能被应用类型实现

    在需要的时候定义一个新的抽象或者特定特点的组， 而不需要修改具体类型的定义
4.flat.Value接口
5.接口值
5.1.一个包含nil指针的接口不是nil接口
6.sort.Interface接口
定义接口：接口做了一个方法的抽象，不管是什么类型的数据排序都要满足这三个接口函数
定义接口实现类型
调用排序sort.Sort(具体类型对象)

tabwriter.Writer 格式化输出包

slice中存储结构体切片，这样在排序的时候交换指针比交换每个Track类型快
指针是一个机器码长度

如果要逆序输出
    sort.Sort(sort.Reverse(具体类型对象))
    函数Reverse返回一个包含原有sort.Interface值的reverse类型实例
    reverse类型Less方法，Sort中调用实现类的Less时传入的参数是 在调用接口方法前先把下标索引换了

sort包为[]int,[]string和[]float64的正常排序提供了特定版本的函数和类型
sort.Ints对int slice排序
sort.IntsAreStored判断是否排序

7.http.Handler接口
进化一：
使用ServeMux 操作逻辑被分到不同的方法中
方法值转为转为Handler的实现类型HandlerFunc
http.HandlerFunc是一个让函数值满足一个接口的适配器
缺点：每次需要转
进化二：改进了传递一个方法值，不用转
ServeMux.HandlerFunc接受的第二个参数是一个函数类型 这样不用转 直接传递方法值就行
进化三：
一个应用程序的多个文件中定义HTTP handler也是非常典型的
net/http包提供了一个全局的ServeMux实例DefaultServerMux和包级别的http.Handle和http.HandleFunc函数
DefaultServeMux作为服务器的主handler，不需要将它传给ListenAndServe函数；nil值就可以工作

注意:如果用协程调用每一个handler 要注意不用协程之间资源的竞争
8.error接口
创建error返回的是一个指针类型，所以错误比较不能直接用==
fmt.Errorf 对错误处理做了封装

syscall包中的Errno根据数值找到对应的错误
Errno是一个系统调用错误的高效表示方式
9.