1.
主函数在执行中，go创建的goroutine也在执行
main执行结束退出，其他的goroutine也一并退出

2.
时间模板：Mon Jan 2 03:04:05PM 2006 UTC-0700
格式化的逆向操作time.Parse

服务端：
    net.Listen启动监听端口,拿到一个监听对象
    监听对象调用Accept方法，会直接阻塞，知道一个请求过来拿到一个连接对象
    处理连接
客户端：
    客户端拨号连接 拿到conn
    io.Copy接收一个

killall 服务名字 , 掉所有名字匹配的进程

改进：
让每次的调用连接处理都进入一个独立的goroutine
这样就可以连接多个客户端

3.
服务端：
从Conn读取输入数据
input := bufio.NewScanner(c)
fmt.Fprintln 把数据写入到管道

客户端：
使用goroutine的方式写数据到服务端
io.Copy会阻塞进程，一直等待输入

4.
goroutine是并发体
channels是之间的通信
channel是引用类型，零值是nil，用make创建
两个相同类型channel可以用 == 比较
写数据发生在通知读数据之前，这样保证了不会死锁
关闭channek后不能写入，当发送的数据读完了，就会读到一个零值的数据
接收操作并不会停止，而是不断的接收零值，可以用一个接收channel判断是否有接收到数据，去判断是否对方已经关闭channel


无缓存会有goroutine堵塞
无缓存channel也叫同步channel
改进：
之前的客户端当主程序执行完后不去等待后台goroutine
当主程序要停止时需要等后台的goroutine执行完成后再退出，这时用一个同步channel实现

当用户端关闭conn，服务端会受到信号end-of-file

用channel将多个goroutine串联起来 就是 pipeline

for range可以直接在channel上迭代，当channel没有数据时 会结束循环，这样就不用用户端去作判断了

不能关闭nil值的channel，不能重复关闭

A->B->C
a有一个channel是out  chan<-
b有两个channel是in和out    in是<-chan
c有一个channel是in
out channel是可以关闭的

定义连个全局的channel,不指定方向，只是在定义方法的时候指定方向
把没指定方向的channel赋值到有方向的channel 隐式转换

声明channel的时候指定容量 就是带缓存的channel

多个goroutine并发的向一个channel写入数据，或者多个从一个channel读取数据
场景：
同时启三个后台goroutine 发送一个请求到三个地址,哪个先返回数据 先用哪个
如果没有缓存接收另外两个,会发生goroutine泄漏

泄漏的goroutine不会被自动回收

一个pipeline有多个环节，后面环节数据的消耗尽量和第一个阶段数据的产生一致，这样就能高效的工作
不能把数据缓存堆到一个环节

5.for声明初始化的变量，常量值在后台goroutine还没之前就已经迭代到最后一个了
所以goroutine 匿名函数是不可以直接使用for中声明的变量，需要在for内部保存一个 或者直接传给goroutine

当一个goroutine还在往channel发送数据，但是接收数据的gouroutine已经停止了，就会有goroutine泄漏，可能导致整个程序卡住或者out of memory

为了知道最后一个goroutine什么时候结束：增加一个计数器 goroutine开始前加1，结束后减1
sync.WaitGroup
wg.Add(1) 保证是在Wait之前调用
defer wg.Done 每次结束goroutine的时候会调用
wg.Wait()让所有goroutine都结束后再关闭管道，死锁 直到wg的counter是0

wg.Wait()等待关闭channel放的位置：
    不能放到主函数 因为他会直接让程序死锁

main goroutine是如何大部分的时间被唤醒执行其range循环，等待worker发送值或者closer来关闭channel的
