1.整型
int8、int16、int32和int64
uint8、uint16、uint32和uint64
int和uint 特定CPU平台机器字大小bit
Unicode字符rune类型是和int32等价的类型
byte也是uint8类型的等价类型  1byte=8bit
byte类型一般用于强调数值是一个原始的数据而不是一个小的整数
无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针
−2^(n−1) 到2^(n−1) − 1
0到2^n − 1
int8类型整数的值域是从-128到127
术运算、逻辑运算和比较运算的二元运算符,它们按照先级递减的顺序的排列:
    * / % << >> & &^
    + - | ^
    == != < <= > >=
    &&
    ||
使用括号也可以用于提升优先级
取模运算符%仅用于整数间的运算
-5%3 和 -5%-3 结果都是-2  %取模运算符的符号和被取模数的符号总是一致的
除法运算符/ 行为则依赖于操作数是否为全为整数,整数除法会向着0方向截断余数

== equal to
!= not equal to
< less than
<= less than or equal to
> greater than
>= greater than or equal to
+ 一元加法 (无效果)
- 负数
& 位运算 AND
| 位运算 OR
^ 位运算 XOR
&^ 位清空 (AND NOT)
<< 左移
>> 右移

var u uint8 = 255
fmt.Println(u, u+1, u*u) // "255 0 1"
var i int8 = 127
fmt.Println(i, i+1, i*i) // "127 -128 1"

fmt.Printf("%08b\n", x) %08b中08表示打印至少8个字符宽度

一个x<<n左移运算等价于乘以2^n ,一个x>>n右移运算等价于除以2^n
左移运算用零填充右边空缺的bit位
无符号数的右移运算也是用0填充左边空缺的bit位
有符号数的右移运算会用符号位的值填充左边空缺的bit位
用无符号运算,可以将整数完全当作一个bit位模式处理

我们还是倾向于使用有符号的int类型
for i := len(medals) - 1; i >= 0; i-- { 如果无符号整数就会i>=0 永远为真

不同精度之间转换需要显示类型转换
浮点数转整数，向数轴零方向截断

ascii 转十进制
unicode 转十进制
ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)// "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
fmt.Printf("%d %[1]q\n", newline)// "10 '\n'"

2.浮点
常量math.MaxFloat32
常量math.MaxFloat64
float32的有效bit位只有23个,其它的bit位用于指数和符号;当整数大于23bit能表达的范围时,float32的表示将出现误差
非数NaN无效的除法操作结果0/0或Sqrt(-1)
NaN和任何数都是不相等的
+Inf -Inf 正无穷大和负无穷大

判断一个数是否非数：math.IsNaN
测试一个结果是否是非数NaN则是充满风险的，NaN和任何数都是不相等的
nan := math.NaN()
fmt.Println(nan == nan, nan < nan, nan > nan) // "false false false"

3.复数
complex64和complex128
float32和float64两种浮点数精度
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y) // "(-5+10i)"
fmt.Println(real(x*y)) // "-5"
fmt.Println(imag(x*y)) // "10"
x := 1 + 2i
y := 3 + 4i

4.布尔型
true和false
如果运算符左边值已经可以确定整个布尔表达式的值,那么运算符右边的值将不在被求值

if 'a' <= c && c <= 'z' ||
  'A' <= c && c <= 'Z' ||
  '0' <= c && c <= '9' {  &&的优先级比||高
// ...ASCII letter or digit...
}

s != "" && s[0] == 'x'  s[0]操作如果应用于空字符串将会导致panic异常。

布尔和整形10不能转换

5.字符串
len(s)长度
s[0]索引，超出panic
+ 两个字符串链接
== < 逐个字节比较
不可修改
5.1.字符串面值

