1.方法声明
    在函数方法名前放一个变量
    将该函数附加到这种类型上， 即相当于为这种类型定义了一个独占的方法
    定义：func (p Point) Distance(q Point) float64{}
        附加参数p 方法的接收器(receiver)
    调用：
       Distance(p, q) 函数调用
       p.Distance(q) 方法调用
       geometry.Path.Distance(perim) 包外调用函数
       perim.Distance() 包外调用方法
    方法和函数可以同名
    方法名和结构体成员名不可以同名，因为选择器p.X会有歧义
    每种类型都有方法的命名空间,不通类型指向不通的方法

2.指针对象的方法
    定义：func (p *Point) ScaleBy(factor float64) {}
    方法名：(*Point).ScaleBy 括号是必须的
    约定：指针作为接收器的方法，一个类要么所有的方法都是指针，要么都不是
    一个类型名本身是一个指针的话， 是不允许其出现在接收器中的
    调用指针类型方法：
        对象的指针.对象类型方法名
    隐式转换：
        接收器形参是类型T，但接收器实参是类型 *T，隐式地为我们取变量的地址
        接收器形参是类型 *T，实参是类型T，隐式地取到指针指向的实际变量
    隐式转换不可用情况：
        这种简写方法只适用于“变量”， 包括struct里的字段比如p.X， 以及array和slice内的元素比如perim[0]
        不能通过一个无法取到地址的接收器来调用指针方法 例如：Point{1, 2}.ScaleBy(2)
    不管你的method的receiver是指针类型还是非指针类型， 都是可以通过指针/非指针类型进行调用的， 编译器会帮你做类型转换
    Nil作为接收器类型：
        前提：当nil对于对象来说是合法的零值时
        net/url案例
            提供了一个 map[string][]string 类型的操作
            m赋值为nil
                m.Get("ite")正常执行，直接写nil.Get("item")的话是无法通过编译的，nil的字面量编译器无法判断其准备类型
                m.Add("","") panic报错，尝试更新一个空map
3.嵌套结构体 扩展类
    扩展类可以调用成员的方法
    成员的类型可以是指针类型
    方法查找优先级：
        定义在这个类型的
        该类定义的成员的方法
        该类嵌套的结构体的方法：不能有重复方法 会有二义性
    结构体类型引入互斥锁sync.Mutex，结构体也就有了clock和unlo
4.方法值和方法表达式
    接收器.方法名  可以看做一个选择器 返回一个方法值：一个函数
    方法值 ： distanceFromP := p.Distance ，distanceFromP(q) 函数调用
        time.AfterFunc(10 * time.Second, r.Launch ) 方法"值"作为函数值传递，不用写一个匿名函数做封装
    方法表达式： distanceFromP := Point.Distance
        (distance(p, q)  将其第一个参数用作接收器
        根据传递的函数参数值，决定调用那个方法
5.Bit数组
6.封装