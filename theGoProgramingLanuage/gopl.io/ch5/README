1.函数声明
func hypot(x, y float64) float64 {
func f(i, j, k int, s, t string){
func first(x int, _ int) int {
func sub(x, y int) (z int){
2.递归
非标准包 golang.org/x/. 扩展包
net/html
findlinks1案例：
    html.Parse解析传入文本
    visit 返回链接href的slice
        递归visit 每层上第一个节点和它的兄弟节点 如果该层是a返回href
outline案例：
    循环遍历子节点和子节点的兄弟节点

3.多返回值：
func findLinks(url string) ([]string, error)
links, _ := findLinks(url)
return findLinks(url)  将另一个有多返回值的函数作为返回值
func CountWordsAndImages(url string) (words, images int, err error) {
    该函数的return语句可以省略操作数 bare return
4.错误
一个良好的程序永远不应该发生panic异常
额外的返回值：
    boole 失败的唯一原因;
    error 导致失败的原因不止一种
        nil意味着函数运行成功
        non-nil表示失败
    cache.Lookup是key不存在失败的唯一原因
    value, ok := cache.Lookup(key)
    if !ok {
4.1.错误处理策略
    err中有报错原因：直接返回 if err != nil { return nil, err }
    err中没有具体说明是哪个导致：自定义返回内容和数据 return nil, fmt.Errorf("parsing %s as HTML: %v", url,err)
    偶然发生的错误，不可预知的问题导致，明智的选择是重新尝试失败的操作：限制重试的时间间隔或重试的次数，仍然报错就结束函数，向上传播错误
        os.Exit(1)
        wait案例：main函数调用函数，如果错误不为空，结束执行 打印错误 os.Exit(1)
        log中的所有函数,都默认会在错误信息之前输出时间信息
        log.Fatalf("Site is down: %v\n", err)
        log.SetPrefix("wait: ") 设置前缀
        log.SetFlags(0)
    只需要输出错误信息，不需要中断程序：
        log.Printf("ping failed: %v; networking disabled",err)
        fmt.Fprintf(os.Stderr, "ping failed: %v; networking disabled\n", err)
    直接忽略错误 return fmt.Errorf("failed to create temp dir: %v",err)
        dir, err := ioutil.TempDir("", "scratch") 创建临时目录
        os.RemoveAll(dir) 清楚临时目录 不做错误处理 即便没有删除 操作系统会定期的清理临时目录
        r, _, err := in.ReadRune()  ;  if err == io.EOF {
文件结尾错误（EOF)：
     io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF
     var EOF = errors.New("EOF")
     固定的错误信息——“EOF
5.函数值  函数类型的变量
    func A(n int) int { return n * n } 定义函数； f := square 函数值f; f（3）函数值的调用
    如果 func B的参数类型和A一样，B类型的对象可以赋值给f，参数不一致则无法赋值
    var f func(int) int 函数的零值是nil ,调用f函数会panic
    函数比较：  if f != nil
    函数值之间不能比较
    outline2案例：
        fmt.Printf("%*s<%s>\n", depth*2, "", n.Data)
        func forEachNode(n *html.Node, pre, post func(n *html.Node))
        函数值作为参数传递 先打印start节点 逐层递进，再打印end节点，逐层返回
6.匿名函数
    func关键字后没有函数名，函数值字面量表达式 称为匿名函数
    strings.Map(func(r rune) rune { return r + 1 }, "HAL-9000")
    squares案例：
        squares() 生成一个局部变量x 并 返回一个类型为 func() int 的函数，f接收这个匿名函数 f是函数值
        每次调用匿名函数，都会对局部变量x进行操作
        第二次调用squares时， 会生成第二个x变量，新匿名函数操作的是第二个x变量


7.变参函数
8.deferred
9.panic
10.recover
可以使用的场景须满足4条：
    deferred函数中调用了内置函数recover
    定义该defer语句的函数发生了panic异常
    recover会使程序从panic中恢复,并返回panic value
    导致panic异常的函数不会继续运行,但能正常返回
在未发生panic时调用recover,recover会返回nil