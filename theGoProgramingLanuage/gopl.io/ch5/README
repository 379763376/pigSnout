1.函数声明
func hypot(x, y float64) float64 {
func f(i, j, k int, s, t string){
func first(x int, _ int) int {
func sub(x, y int) (z int){
2.递归
非标准包 golang.org/x/. 扩展包
net/html
findlinks1案例：
    html.Parse解析传入文本
    visit 返回链接href的slice
        递归visit 每层上第一个节点和它的兄弟节点 如果该层是a返回href
outline案例：
    循环遍历子节点和子节点的兄弟节点

3.多返回值：
func findLinks(url string) ([]string, error)
links, _ := findLinks(url)
return findLinks(url)  将另一个有多返回值的函数作为返回值
func CountWordsAndImages(url string) (words, images int, err error) {
    该函数的return语句可以省略操作数 bare return
4.错误
一个良好的程序永远不应该发生panic异常
额外的返回值：
    boole 失败的唯一原因;
    error 导致失败的原因不止一种
        nil意味着函数运行成功
        non-nil表示失败
    cache.Lookup是key不存在失败的唯一原因
    value, ok := cache.Lookup(key)
    if !ok {
4.1.错误处理策略
    err中有报错原因：直接返回 if err != nil { return nil, err }
    err中没有具体说明是哪个导致：自定义返回内容和数据 return nil, fmt.Errorf("parsing %s as HTML: %v", url,err)
    偶然发生的错误，不可预知的问题导致，明智的选择是重新尝试失败的操作：限制重试的时间间隔或重试的次数，仍然报错就结束函数，向上传播错误
        wait案例：main函数调用函数，如果错误不为空，结束执行 打印错误
    log中的所有函数,都默认会在错误信息之前输出时间信息
        log.Fatalf("Site is down: %v\n", err)
        log.SetPrefix("wait: ") 设置前缀
        log.SetFlags(0)
文件结尾错误（EOF)
5.函数返回值
6.匿名函数
7.变参函数
8.deferred
9.panic
10.recover
可以使用的场景须满足4条：
    deferred函数中调用了内置函数recover
    定义该defer语句的函数发生了panic异常
    recover会使程序从panic中恢复,并返回panic value
    导致panic异常的函数不会继续运行,但能正常返回
在未发生panic时调用recover,recover会返回nil